Source - https://youtu.be/zL4mjpYpRmc
..............................Back Tracking............................
Exhaustive Search : Exploring every possible combination from a set of choices or values. 
-- often implemented recursively. 
Application.
-producing all permutations of a set of values.
-enumerating all possible name,  password, etc. 
-combinatories and logic programming. 

General pseudo-code for exhaustive search. 

Search(decisions):
    - If there are no more decision to make: Stop. 
    - else, let's handle one decision by ourselves and the rest by recursion 
    for each available choice C for this decision: 
    * Choose C
    * Search the remaining decisions that could follow C.

Often the search space consist of many decisions, each of which have several available choices. 

Exercise 1: Print all possible 3 digit binary number using recursion. 

//print all 3 digit binary number 
void printBinary(int digit, string prefix) {
    if(digit == 0){
        cout<<prefix<<endl;   //base case
    }
    else {
        //recursive case
        printBinary(digit-1, prefix + "0");
        printBinary(digit-1, prefix + "1");
    }
}

int main(){
    string prefix = "";
    printBinary(3, prefix);
    
}

//Print all 2 digit decimal number using recursive and a for loop

void printDecimal(int digit, string prefix){
    if(digit == 0){
        cout<<prefix<<endl;
    }
    else {
        for(int i = 0; i < 10; i++){
            printDecimal(digit-1, prefix + to_string(i));
        }
    }
}

int main(){
    string str = "";
    printDecimal(2, str);
}

............................Examining the Problem............................

Let say you have three dice to roll and print all the possible output.
(1, 1, 1)                    
(1, 1, 2)
(1, 1, 3)    We can do this by using three nested for loop 
(1, 1, 4)    for(each possible first dice value)
(1, 1, 5)       for(each possible second dice value)
.........           for(each possible third dice value)
.........                  print something; 
(2, 1, 5)      ---> This is called Depth First Search <---
(2, 1, 6)
.........
.........
(4, 1, 1)
(4, 1, 2)
.........
(6, 6, 6)

>> The better approach to solve this kind of problems are using "Back Tracking"
Backtracking - Finding solutions by trying partial solutions and then abandoing them if they are not suitable.  

-- a "brute force" algorithm technique (try all path) 
-- often implementated recursively

Application:
1. Producing all permutation from a set of values 
2. Prasing Language
3. Games: Anagrams, crossword, word jumbles, 8 queen. 
4. Combinatories and logic programming 
5. escaping from maze

General Pseudo - code algorithm for back tracking problems:
Explore (decisions):

- If there are no more decision to make: stop
- else, lets handle one decision ourselves, and the rest by recursion.
- for each available choice C for this decision: 
   Choose C
   Explore the remaining choices that could follow C
   Un-choose C (BackTrack)

Exercise 1: We have three dice to roll and print all the possible output.

void diceHelper(int dice, vector<int>& choosen){
    if(dice == 0){
        //base case
        for (int i = 0; i < choosen.size(); i++) {
             cout << choosen.at(i) <<" ";
        }
        cout<<"\n";
    }
    else{
        // some dice left to role 
        //handle one dice 
        //for each value that dice could have
        for(int i = 1; i <= 6; i++){
            //choose
            choosen.push_back(i);
            //explore 
            diceHelper(dice - 1, choosen);
            //un-choose
            choosen.pop_back();
        }
    }
}

void diceRoll(int dice){
    vector<int> choosen; 
    diceHelper(dice,  choosen);
}

int main(){
    diceRoll(3);
}


dicerolles:

diceHelper 3, {}
  diceHelper 2, {1}
     diceHelper 1, {1, 1}
        diceHelper 0, {1, 1, 1}
           {1, 1, 1}
        diceHelper 0, {1, 1, 2}
           {1, 1, 2}
        diceHelper 0, {1, 1, 3}
           {1, 1, 3}
        diceHelper 0, {1, 1, 4}
           {1, 1, 4}
        diceHelper 0, {1, 1, 5}
           {1, 1, 5}
        diceHelper 0, {1, 1, 6}
           {1, 1, 6}   
           
